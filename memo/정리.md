



-우리는 항상 다른 사람들의 하이라이트만 본다. -> 타인의 결과물만 중시<br>
-모든걸 다 아는 완벽한 전문가가 될 수 없다. <br>
-내가 취약하다고 느끼는 부분을 분석해본다 -> 언제 임포스터 신드롬을 느끼는지, 언제 특정한 업무만 하면 느리다고 혼나거나 퍼포먼스가 제대로 안나오는지, 언제 슬럼프를 느끼는지 -> 이 부분에 대한 개선 방안은? <br>
-성장의 길을 택하자 -> 나의 하이라이트 기록, 성취/성장 스토리 만들기, 실수를 통해 배우기, 어제보다 나은 오늘의 실력.<br>
<br>

-메모 자주하기 : 내가 모르는 것들 적고 지금 바로 공부하기 (회사 일이 바쁘다, 할 일이 많다고 미루면 1~2년뒤에도 미뤄서 평생 모름) <br>
-평일, 주말 어떤걸 공부할 지 정리하기, 일주일 중 하루는 코딩 안하기 (번아웃 방지) <br>
-우선순위 정하기- T자로 공략하기 -> 주력 스킬 키우기 (ex. 백엔드니까 자바/스프링, 특정 툴 사용스킬 등 디테일하게 )<br>
-3의 법칙 : 똑같은 일을 3번째 하면 리팩토링 해라<br>
-유행하는 기술만 쫓지않기 : 분리할 서비스 간 통신 구현 할때 카프카 사용하고, 쿠버네티스로 클러스터를 구축해서 서비스 구동하고 그러면 기술은 적용해서 복잡성은 증가했는데 문제는 해결이 되지 않는다

<br>

<br>
mysql - 최대커넥션유지시간, 개수, 계정권한<br>
메시징 - 비동기로 메시지를 주고 받기 위해 카프카 사용할 때 주요구성요소인 파티션, 레플리카, 프로듀서, 컨슈머 동작이해, (데이터손실과 중단을 막기위해서)<br>
클라우드 - aws 서비스 요소와 기본적인 설정 방법<br>
os - 부팅시 자동으로 프로그램 시작하기, 권한설정, 스케줄링 하기, 운영체제 상태보기 등 서비스 운영할 때 필요한 설정/명령어 등<br>
spring, mybatis, jpa, tomcat <br>
<br>


jpa <br>
Kotlin<br>
WebFlux<br>
Kafka 를 사용한 비동기 연동 (카프카 장점:비동기연동/ 단점:복잡도 증가)<br>
마이크로서비스 아키텍처(기능이적고 사용자가 많지 않은데 기능을 잘게 나눠 별도 서비스로 분리하면 서비스를 분리했을 때 얻는 이점이 반감된다)<br>
———
기본적으로 알아야할 지식<br>
http 프로토콜 <br>
네트워크 프로그래밍 기초<br>
동시성 처리<br>
프로그래밍 언어<br>
하이버네이트와 같은 orm 도구<br>
——
기술을 도입할때 왜 이 기술을 도입했는지, 목적과 목표<br>

——

### 메서드 분리<br>
메소드 분리를 하는 이유 : 응집도를 높이고, 유지보수를 용이하게 하기 위해서이다. <br>
메소드 분리 방법 <br>
1.두 기능 중 한 기능을 위한 메서드 추가. <br>
2.기존 메서드를 호출하는 코드가 새 메서드를 호출하도록 변경<br>
3.기존 메서드의 코드를 새 메소드로 이동<br>
4.이름 변경 <br>
5.코드 정리 <br>

### 테스트
테스트 커버리지는 7~80%가 적당. 그 이상이면 필요없는 테스트 코드까지 만들게 됨.<br>
예외 상황에 대한 테스트 코드 먼저 작성 후 정상적인 상황에서 테스트 작성 == 테스트 커버리지 높아짐 <br>
리팩토링을 위한 테스트 작성은 우선 기존 코드 검증하는 테스트 코드를 작성한다. <br>
이때 일부만 별도의 타입으로 분리한다음에 테스트를 진행해야하지만 그게 어려운 경우라면 통합 테스트 코드를 작성한다. <br>

###  아키텍처 설계
아키텍처 설계 할때 보통 성공한 아키텍처를 계속 사용하는데 매번 동일한 아키텍처를 사용하면 안됨 <br>
(Ex. 게임 서비스는 24/7 서비스를 제공해야하지만 기업 HR 시스템은 장애 영향도가 크진 않음.  <br>
보안은 그 반대. 게임은 민감하지 않지만, HR 시스템은 데이터베이스 자체를 암호화하는등 보안에 신경써야함.) <br>
 <br>
일관성이 중요한 api 서버는 트랜잭션 처리가 용이한 아키텍처가 적합. <br>
반면 채팅 시스템은 비동기 메시징 처리가 용이한 아키텍처가 적합.  <br>
 <br>
마이크로서비스 아키텍처를 선택하면 탄력성, 배포 가능성(독립적 배포)이 커지지만 데이터 무결성을 위한 구조는 더 복잡. <br>




### mysql
mysql
기본구조<br>
Parser <br>
쿼리를 토큰으로 나눠 트리 형태의 구조로 만듬<br>
기본 문법 오류 체크 <br>

Preprocessor <br>
Parse tree 로 sql 문장구조 체크<br>

Query optimizer <br>
Sql 에 대한 실행 계획을 수립<br>
수립 방법은 role based optimizer, case based optimizer <br>

Query execution engine<br>
만들어진 실행 계획대로 각 핸들러에게 요청<br>

### 읽어보기
- [MySQL 에서 MariaDB 로 마이그레이션 해야할 10가지 이유](https://xdhyix.wordpress.com/2016/03/24/mysql-%EC%97%90%EC%84%9C-mariadb-%EB%A1%9C-%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98-%ED%95%B4%EC%95%BC%ED%95%A0-10%EA%B0%80%EC%A7%80-%EC%9D%B4%EC%9C%A0/)
- [JVM memory leak](https://techblog.woowahan.com/2628/)


