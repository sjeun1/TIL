
## 동시성 문제 해결 사례

### 배경
회사에서 쿠폰 발급 이벤트 시 발급된 쿠폰의 재고 수량 관련해서 관리가 필요하였다. <br>
사용된 쿠폰 수량의 경우에는 별도의 확인 없이 ci 만 조회 되어도 되었다. <br>


### 문제
재고 수량 관련 처리 테스트중 발급된 쿠폰이 정확하게 감소하지 않았다. <br>
확인 결과 자바가 멀티쓰레드 환경이기 때문에 발생한 동시성 문제라는 걸 파악했다. <br>


### 분석
동시성 문제에 대해 아래와 같은 해결 방법을 생각하였다. <br>

1. synchronized 사용
   - public synchronized void (메서드 수준의 동기화) : 메서드를 호출하는 객체에 대한 락을 검. 다른 스레드는 이 객체에 대한 락을 얻기 전 까지 대기해야함. 단일 서버 환경에서만 유효. 분산 시스템에서는 효과적이지 않음. <br>
   - @synchronized : 별도의 프라이빗 락 객체를 사용하여 특정 메서드에만 락을 걸 수 있다. . static 메서드에 사용할 때 클래스 레벨에서의 동기화도 지원. (@Synchronized는 객체의 모든 동기화된 메서드가 같은 락을 공유하지 않고, 더 세밀한 락 제어가 필요할 때 유용. 그렇지만 @Synchronized 는 트랜잭션이 끝나고 나서야 반영되지만 그전에 끝나기 때문에 트랜잭션이 끝나기 전에 변경된 엔티티를 DB에 flush 해주거나, 더 넓은 범위의 트랜잭션에서 Synchronized처리를 해줘야함 )
2. 데이터베이스 레벨에서의 Lock 사용
  - 비관적 락 : 사용자가 재고를 감소하기 전 데이터를 잠금 상태로 만들어서 트랜잭션이 접근하지 못하게 함. 예를 들어 SELECT FOR UPDATE 을 사용하며 락을 걸기 <br>
              (동시성이 높은 경우 성능 저하를 초래할 수 있으므로 낙관적 락이나 redis 기반의 락을 사용하는 것이 효율적일 수 있음.)
  - 낙관적 락 : 애플리케이션 레벨에서 처리하고, 데이터 수정 시 version 필드를 사용하여 다른 트랜잭션에 의한 변경을 감지하고 충돌이 발생하면 트랜잭션을 롤백하고 재시도하는 방식으로 함 (트랜잭션 충돌이 자주 일어나는 경우에는 사용 X)
3. 분산 환경에서 redis 사용

4. 메시지 큐를 아용한 비동기 처리
   - rabbitMQ, Kafka 와 같은 메시지 큐를 사용하여 재고 감소를 비동기로 처리. 즉시 감소가 필요하는 경우는 적합하지 않음.

높은 트래픽인 경우에는 DB 락 보다는 redis 와 같은 분산 락을 사용하거나 메시지 큐 기반의 비동기 처리를 선호한다. <br>


## 해결 
