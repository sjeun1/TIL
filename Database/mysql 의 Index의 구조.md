## Mysql 과 Index 구조.md 

### Index 란,
인덱스는 테이블의 특정 컬럼에 대해 별도의 데이터 구조를 생성하는 방식이며, 원하는 데이터를 바로 찾아 갈 수 있는 포인터 역할을 한다. <br>
데이터베이스에서는 사용하는 인덱스 구조는 다양한데 대표적으로 B+Tree 인덱스와 Hash 인덱스를 많이 사용한다. <br>
B+Tree 는 범위 검색과 정렬이 필요할 때 주로 사용되며, Mysql 의 InnoDB 와 같은 스토리지 엔진에서 많이 사용된다. <br>
또한 InnoDB 엔진은 기본적으로 Clustered Index 방식을 사용한다. (데이터 자체가 인덱스의 리프 노드에 저장) <br>
<br><br>


## Clustered Index 와 Non Clustered Index 

### Clustered Index 란
Clustered Index 는 데이터베이스 테이블의 데이터가 실제 물리적으로 정렬되어 저장하는 데이터 구조이다. <br>
클러스터형 인덱스는 클러스터형 키를 기준으로 테이블의 행을 정렬한다. <br>
하나의 테이블에 하나의 클러스터드 인덱스만 생성하는데, 보통 기본키 (primary key) 로 자주 사용하며 기본 키(primary key) 나 유니크한 값을 기준으로 조회 할 때 Clustered Index 는 필수적이다. <br>
Clustered Index로 인해 데이터가 정렬된 상태로 저장되어 인덱스를 통한 검색 속도가 매우 빠르다. <br>
```
- 성능에 유리한 경우
  - 범위 조회 (BETWEEN, >=, <=)
  - 자주 사용하는 정렬된 데이터나 프라이머리 키인 경우
- 성능 저하가 발생하는 경우
  - 자주 업데이트 되거나 삭제되는 테이블
```
<br>

### Non Clustered Index 란
인덱스는 데이터가 있는 위치를 가리키는 포인터 역할만 하고, 실제 데이터는 테이블에 저장된다. <br>
Non Clustered Index 는 하나의 테이블에 여러 개 생성하여 복합 인덱스가 가능하다. <br>
큭정 컬럼에 대해 빠르게 검색하고자 할 때 사용되며 데이터 자체는 정렬되지 않지만 인덱스는 정렬된 상태이다. <br>
Clustered 보다 상대적으로 느리다. <br>
```
- 성능에 유리한 경우
  - 특정 컬럼을 자주 조회 할 때
  - 삽입/삭제가 적고 SELECT 가 많은 테이블
  - 조회 조건이 많은 경우
- 성능 저하가 발생하는 경우
  - *인덱스 Lookup 비용
  - *커버링 인덱스가 없는 경우
```
 
*인덱스 Lookup : 인덱스를 통해 데이터를 찾아가는 과정을 뜻하며 추가적인 I/O 비용이 발생한다. <br>
*커버링 인덱스 : 쿼리에서 필요한 모든 데이터를 인덱스만으로 처리할 수 있는 경우이다. <br>
  ex) SELECT name, phone FROM Users WHERE name = 'sj'; 의 쿼리인 경우 name, phone 만 모두 인덱스에 포함되어있다면 테이블 조회없이 바로 인덱스만으로 결과를 반환할 수 있다. <br>
<br><br><br><br><br>


## B-Tree 와 B+Tree

### B-Tree 특징
B-Tree 는 균형 트리로, 각 노드는 여러개의 자식을 가질 수 있으며 하나의 노드에는 여러개의 키와 포인터가 저장된다. <br>
내부 노드와 리프 노드 둘 다 데이터를 저장할 수 있으며, 정렬된 상태로 유지되어 빠른 검색이 가능하다는 특징이 있다. <br>
리프 노드는 서로 연결되지 않고, 범위 검색이 비교적 느리다. <br>
<br>

### B+Tree 특징
B-Tree 의 확장판이며, 리프 노드에만 실제 데이터가 저장되고, 내부 노드는 검색을 위한 인덱스 역할만 한다. <br>
모든 리프 노드는 링크드 리스트로 연결되어 있어 순차검색에 유리하며, 물리적으로 정렬되기 때문에 범위검색에 효율적이다. <br>
리프 노드에는 모든 키 값이 포함되어 있어, 트리의 높이를 최소화하고 데이터 접근 속도를 높인다. <br>
<br><br><br>


### 왜 DB Index 로 B Tree 계열이 사용 되는지? 
B-Tree 는 avg case 와 worst case 의 조회/삽입/삭제를 체크 했을 때 아무리 오래걸려도 O(logN) 의 시간복잡도가 소요된다. <br>
<br>

근데 여기서 궁금한 점은 self-balancing BST (AVL tree, Red-Black tree) 도 O(logN) 인데 왜 B Tree 인지 확인이 필요했다. <br>
여러가지 경우가 있는데 일반적으로는 아래의 이유가 있었다. <br>
```
1. 불균형 이진탐색트리 : 이진트리에서 최악의 경우 데이터 수만큼 확인하는 O(N) 로 나오는데 B Tree 인 O(logN) 보다 성능이 좋지 않다. <br>
2. B-Tree의 노드구조 및 디스크 I/O 최적화 : DB 는 * secondary storage 에 저장되어 적게 접근하는 것이 좋은데 B-Tree는 한 노드에 여러 개의 키와 데이터를 저장할 수 있도록 설계되어 있고, 이로 인해 트리의 깊이가 줄어들어 디스크 접근 횟수를 최소화할 수 있다. <br>
3. 범위검색 : BST 의 범위검색은 범위의 최소값을 찾은 뒤, 중위 순회를 통해 범위 내에 있는 모든 노드를 탐색하는 거에 비해 B-Tree 는 노드를 순서대로 읽어나가며 순차적 데이터 접근이 가능하기 때문에 범위 쿼리가 자주 발생할 때 용이하다. <br>
4. 삽입과 삭제의 효율성 : BST 는 추가 작업이 필요할 수 있지만 B-Tree 는 삽입/삭제에도 균형을 유지한다. <br>
```
* secondary storage (SSD or HDD) : 프로그램과 데이터가 영구적으로 저장. 실행중인 프로그램 데이터 일부 임시저장. db 도 아래에 저장됨 <br>

<br><br><br><br><br><br>

## Index 생성 시 고려사항 
- 여러 테이블을 조인할 때 조인에 사용되는 컬럼에 인덱스를 추가하면, 데이터 조회 속도를 향상 시킬 수 있다. <br>
- 인덱스를 너무 많이 만들면 데이터 입력/수정 시 성능이 저하 될 수 있으므로, 필요한 인덱스만 생성하는 것이 필요하다. <br>
- 검색 빈도가 높은 컬럼이나 정렬, 조인에 자주 사용되는 컬럼에 인덱스를 생성하는 것이 유리하다. <br>
- 간단한 서브쿼리는 성능저하가 크지 않지만, 복잡한 서브쿼리를 쓸 때는 필요한 경우에만 사용하고 가능하다면 인덱스를 사용한 조인으로 변환하는 것이 성능에 유리하다.  <br>
- 조인이 너무 많은 테이블을 포함 할 경우에는 조인 순서를 최적화 한다. <br>
- 잘못된 순서로 복합 인덱스를 생성하면 오히려 테이블 스캔이 발생할 수 있다. <br>
- 일반적으로 cardinality 가 높을수록 인덱스 효율이 좋기 때문에 가장 높은 것으로 잡아야한다. 여러개라면 높은 순에서 낮은 순으로 (중복값이 적을수록 성능이 잘나옴) <br>
- WHERE 절에서 자주 사용되는 컬럼이나, JOIN, ORDER BY, GROUP BY 등에서 자주 사용되는 컬럼에 적절한 인덱스를 설정해야 한다. <br>
- BETWEEN, LIKE, <, > 등 범위 조건은 해당 컬럼은 인덱스를 타지만, 그 뒤 인덱스 컬럼들은 인덱스가 사용되지 않는다. (=, in 은 인덱스 사용) <br>
- 와이드카드(%) 는 끝에 작성하는 것이 좋다. <br>
- WHERE 절에서 OR 을 사용할 때는 비교해야할 ROW 가 들어나기 때문에 풀 테이블 스캔 확률이 높아지고 OR 을 사용해야한다면 UNION 을 사용하는 것이 좋다. (AND 는 ROW 를 줄임) <br>
<br><br><br><br><br>

### 참고
https://orangematter.solarwinds.com/2022/10/26/mysql-indexes-tutorial/ <br>
https://en.wikipedia.org/wiki/B-tree  <br>
https://medium.com/@yogeshsherawat/why-b-trees-are-used-in-databases-not-binary-search-trees-8aebdb9c1b50 <br>
https://www.youtube.com/watch?v=liPSnc6Wzfk&list=PLcXyemr8ZeoR82N8uZuG9xVrFIfdnLd72&index=28 <br>




