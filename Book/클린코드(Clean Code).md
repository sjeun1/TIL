

![image](https://user-images.githubusercontent.com/62210870/178767705-f8ddb4c4-08c9-4c7b-a9b6-9d82f6526191.png)
<br><br><br><br><br>


## 클린 코드(Claen Code)

#### 목차
- [깨끗한 코드와 나쁜 코드](#깨끗한-코드와-나쁜-코드)
- [의미있는 코드](#의미있는-코드)
- [함수](#함수)
- [주석](#주석)
- [형식 맞추기](#형식-맞추기)
- [객체와 자료구조](#객체와-자료구조)
- [오류 처리](#오류-처리)
- [경계](#경계)
<br><br><br><br>


## 깨끗한 코드와 나쁜 코드

#### 나쁜 코드란?
나쁜 코드는 개발 속도를 저하시키고 고칠 때마다 엉뚱한 곳에서 문제가 생긴다.<br>
나쁜 코드가 쌓일 수록 속도저하 등으로 팀 생산성이 떨어진다. 생산성을 증가시키기 위해서는 프로젝트에 인력을 추가로 투입한다. <br>
하지만 투입이 얼마 안 된 새 인력이라면 시스템을 깊게 알지 못하고 압박에 시달린다. 그로 인해 생산성이 더욱 떨어진다.<br>
이와 같은 상황이 되지 않고 기한을 맞추면서 빨리 가는 방법은 언제나 코드를 깨끗하게 유지하는 것이다.<br>

그렇다면 깨끗한 코드란 무엇일까? <br>
책에서 나온 전문가들은 이렇게 설명하고 있다.<br>


#### 깨끗한 코드란?
-&nbsp;논리가 간단하며 의존성을 최대한 줄이며 각 의존성을 명확하게 정의한다.<br>
-&nbsp;중복이 없다. <br>
-&nbsp;단순하고 직접적이다. 가독성이 좋고 설계자의 의도를 숨기지 않는다.<br>
-&nbsp;타인이 읽어도 읽기 쉽고 고치기 쉽다. 의미있는 이름이 붙는다.<br>
-&nbsp;간단한 추상화 고려한다.<br>
-&nbsp;특정목적을 달성하는 방법은 여러가지가 아니라 하나만 제공한다.<br>
-&nbsp;단위 테스트 케이스와 인수 테스트 케이스가 존재한다. 테스트 시 모든 테스트를 통과한다.<br>
-&nbsp;주의깊게 짠다. 다시 고칠 필요가 없도록, 모든 상황을 고려하여서.<br>
<br>
<br>
<br>
<br>
## 의미있는 코드

#### &nbsp;의도를 분명히 한다 
-&nbsp;변수명이 경과시간이라면 int d; 보다는 int elapsedTimeInDays; 로 명확하게 정의하는 것이 낫다. 
<br><br>

#### &nbsp;잘못된 정보를 피한다 
-&nbsp;그룹으로 묶을 때 실제 List 가 아니라면 accountList 라는 식으로 명명하지 않는다.
-&nbsp;accoutGroup, Accounts, bunchOfAccounts 등이 더 옳은 표현이다.
-&nbsp;헷갈릴만한 유사한 이름을 사용하지 않는다.
<br><br>

#### &nbsp;의미있게 구분한다.
-&nbsp;숫자를 붙인 이름은 사용하지 않는다. (ex.  a1, a2 ..)
-&nbsp;불용어를 추가하는 방식은 적절하지 못한다. (ex.  Product, Products, ProductInfo, ProductData ..)
<br><br>

#### &nbsp;발음하기쉬운 이름을 사용한다.
-&nbsp;genymdhms -> generationTimestamp 
<br><br>

#### &nbsp;검색하기 쉬운 이름을 사용한다.
<br><br>

#### &nbsp;인코딩을 피한다
-&nbsp;헝가리식 표기법(변수이름에 타입인코딩할 필요 X), 멤버 변수 접두어(X), 인터페이스/구현클래스 사용 시 인코딩이 필요한 경우라면 구현 클래스에 인코딩.
<br><br>

#### &nbsp;클래스이름 : 명사나 명사구가 적합 (customer, payment)

#### &nbsp;메서드이름 : 동사나 동사구가 적합 (insertCustomer, postPayment) 접급자/변경자/조건자는 get, set, is 등이 붙는다

#### &nbsp;한개념에 한단어를 사용한다

#### &nbsp;해법영역에서 가져온 이름을 사용한다 
-&nbsp;전산용어, 알고리즘 이름 등 기술개념에는 기술이름이 가장 적합(ex. visitor패턴 사용시 AccountVisitor, 멀티프로세싱때 jobQueue 메소드)
<br><br>

#### &nbsp;문제영역에서 가져온 이름을 사용한다
-&nbsp;적절한 개발 용어가 없으면 문제영역에서 가져와서 분야 전문가가 파악 가능.
<br><br>

#### &nbsp;의미 있는 맥락을 추가한다.
-&nbsp;firstName, street, city, state, zipcode 를 보면 주소라는 사실을 알지만 state 변수 하나만 사용한다면 state 가 주소 일부라는 사실을 빠르게 파악하기가 힘들다.
-&nbsp;같은 변수라도 addr 접두어를 추가하여  addrFirstName 라고 쓰면 맥락이 분명해진다.
<br><br>

#### &nbsp;불필요한 맥락을 없앤다.
-&nbsp;의미가 분명할 경우에 한해서는 짧은 이름이 긴 이름보다 좋다. 
&nbsp;accountAdress, customerAddress 는 Address 클래스 인스턴스로는 좋은 이름이지만 클래스 이름으로는 적합하지 않다.<br>
-&nbsp;postalAddress, MAC, URI 등 분명한 이름으로 붙이는게 좋다.
<br><br><br><br>



## 함수

#### 함수는 작게 만들고, 한번에 한가지만 처리 해야 한다.
-&nbsp;함수는 작게 만들고, 한번에 한가지만 처리 해야 한다.<br>
-&nbsp;함수 내 모든 문장의 추상화 수준이 동일해야한다. <br>
-&nbsp;코드는 위에서 아래로 내려가는 내려가기 규칙을 사용하는 것이 좋다. <br>
<br>
#### * 추상화를 적용하기 위해서 * 
1. 어려운 조건문이나 반복문을 쪼개서 모듈화 시킨다.
2. 상수에 이름을 붙여 상수의 의미하는 바를 파악한다.
3. 반복되는 코드와 불필요한 코드를 파악하고 줄인다

추상화의 목적은 목적을 명확히 하고 핵심만 드러내는 것이다.
추상화 수준이 높고 낮은지를 어떻게 알수 있는가?
추상화 수준이 높다는 것은 디테일을 많이 숨겼다는 것. (어려운 조건문, 반복문 쪼개서 모듈화)
추상화 수준이 낮다는 것은 디테일이 많이 드러났다. 
<br>
#### 내려가기 규칙
-&nbsp;위에서 아래로 읽혀야 한다. 그렇게 짜면 추상화 수준을 일관관되게 유지하기가 쉬워진다.<br>
<br>
#### Switch 문
-&nbsp;한가지 작업, 짧은 Switch 문은 만들기 어려우므로 추상 팩토리를 사용하여 숨긴다. <br>

#### 서술적인 이름을 사용한다

#### 함수 인수를 줄인다. 테스트 케이스 작성도 힘들고 3개가 넘어가면 이해도 힘들다.

#### 플래그 인수, 출력인수를 줄인다
<br>


## 주석
잘 달린 주석은 유영하지만 근거 없는 주석은 오히려 코드를 더 이해하기 힘들게 한다.<br>
함수나 변수로 표현 할 수 있다면 주석을 안다는 것이 좋다.
<br>

#### 주석은 나쁜 코드를 보완하지 못한다.
-&nbsp;코드가 깔끔하며 주석이 거의 없는 코드가 코드 품질이 낮아서 주석을 많이 달린 코드보다 좋다. <br>
<br>

#### 좋은 주석
-&nbsp;법적인 주석 <br>
-&nbsp;정보를 제공하는 주석(ex. 추상메서드가 반환할 값을 설명) <br>
-&nbsp;의도를 설명하는 주석 <br>
-&nbsp;의미를 명료하게 밝히는 주석 <br>
-&nbsp;결과를 경고하는 주석 <br>
-&nbsp;TODO 주석 <br>
-&nbsp;공개 API에서 javdocs <br>
<br>

#### 나쁜 주석
-&nbsp;의무감으로 다는 주석<br>
-&nbsp;코드와 같은 이야기를 중복하는 주석<br>
-&nbsp;오해소지가 있는 주석(ex.잘못된 정보 등)<br>
-&nbsp;이력을 기록하는 주석<br>
-&nbsp;위치를 표시하는 주석<br>
-&nbsp;닫는 괄호에 다는 주석<br>
-&nbsp;저자를 표시하는 주석<br>
-&nbsp;주석으로 처리한 코드<br>
<br><br><br>


## 형식 맞추기
팀 규칙과 형식을 정하여 코드 컨벤션을 맞춤으로써 유지보수 및 가독성을 높일 수 있다. 
<br>

#### 적절한 행길이 유지
-&nbsp;신문기사 처럼 작성한다. (이름은 간단하면서 설명이 가능하도록. 이름만 보고도 올바른 모듈을 살펴보는지 판단할 정도로)<br>
-&nbsp;개념은 빈 행으로 분리한다.(=줄바꿈)<br>
-&nbsp;세로 밀집도(밀접한 코드는 가까이)<br>
-&nbsp;수직 거리<br>
  -&nbsp;변수선언 : 변수는 사용하는 위치에 최대한 가까이<br>
  -&nbsp;인스턴스 변수 : 인스턴스 변수는 클래스 맨 처음에 선언. 변수 간에 세로로 거리를 두지 않는다.<br>
  &nbsp;(많은 클래스 메서드가 인스턴스 변수를 사용하기 때문)<br>
  -&nbsp;종속 함수 : 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. <br>
  -&nbsp;개념적 유사성 : 친화도가 높을수록 코드를 가까이 배치한다. (친화력은 명명법이 똑같고 기본 기능이 유사하고 간단)<br>
-&nbsp;세로 순서(함수 호출 종속성은 아래 방향으로 유지. 홏출되는 함수를 호출하는 함수보다 나중에 배치)<br>
<br>

#### 가로 형식 맞추기
-&nbsp;가로 공백과 밀집도 (ex. 할당 연산자, 연산자 우선순위 강조)<br>
<br>

#### 팀 규칙
-&nbsp;괄호, 들여쓰기, 클래스, 변수, 메서드 이름 정하기, 팀의 IDE 코드 형식기 설정 등 <br>
<br><br><br>


## 객체와 자료구조
private 로 정의된 변수는 남들이 변수에 의존하지 않게 만들고 싶어서 private으로 정의하는데 왜 조회(get), 설정(set) 함수를 public 으로 비공개 변수를 외부에 노출할까?
<br>

#### 자료 추상화
자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 것이 좋다.
<br>

#### 자료/객체 비대칭
객체
  -&nbsp;추상화 뒤로 자료를 숨긴 채 자료를 다르는 함수만 공개한다.<br>
  -&nbsp;객체지향 코드는 기존 함수를 변경하지 않으면 새 클래스를 추가하기 쉽다.<br>
  -&nbsp;객체지향 코드는 모든 클래스를 고쳐야 해서 새로운 함수를 추가하기 어렵다.<br>
자료
  -&nbsp;자료는 그대로 공개하며 별다른 함수는 제공하지 않는다.<br>
  -&nbsp;절차적인 코드는 자료구조를 변경하지 않고 함수 추가하기 쉽다.<br>
  -&nbsp;모든 함수를 고쳐야되서 새로운 자료 구조 추가가 어렵다.<br>
<br>

#### 디미터 법칙
모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.
ex) 클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야한다. 
  -&nbsp;클래스C <br>
  -&nbsp;f가 생성한 객체 <br>
  -&nbsp;f인수로 넘어온 객체 <br>
  -&nbsp;C 인스턴스 변수에 저장된 객체 <br>
  위 객체에서 허용된 메서드가 반환하는 객체의 메서드는 호출하면 안된다.
-&nbsp;기차 충돌이라고 하는 디미터 법칙 관련 코드(ebook,P123-4 참고)가 있는데 해당 코드가 객체인지 자료 구조인지에 따라 법칙 위반/미적용으로 나뉜다.
-&nbsp;때때로 절반은 객체, 절반은 자료구조인 잡종 구조가 나오는데 새로운 함수, 새로운 자료 구조도 추가하기 어려운 단점만 모아놓은 구조로 지양하는 것이 좋다.
-&nbsp;구조체 감추기 : 만약 기차 충돌 예제 코드에서 해당 부분이 객체라면 내부 구조를 감춰야한다.
<br>

#### 자료 전달 객체
자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스이다. 이런 자료 구조체를 때로는 자료 전달 객체(Data Transfer Object, DTO)라고 한다.
DTO 는 데이터베이스에 저장된 가공되지 않은 정보를 어플리케이션 코드에서 사용할 객체로 변환하는 단계에서 처음으로 사용하는 구조체이다.
일반적인 형태는 빈(Bean) 구조이다 빈은 비공개(private) 변수를 조회/설정 함수로 조작한다.

-&nbsp;활성레코드<br>
  -&nbsp;DTO 의 특수한 형태. 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조. 대게 save, find 와 같은 탐색 함수도 제공한다.<br>
  -&nbsp;활성레코드에 비즈니스 규칙 메서드 추가해서 자료구조를 객체로 취급하면 안된다.(잡종구조가 나오기 때문에)<br>
  -&nbsp;해결책은 활성 레코드는 자료 구조로 취급해야 하는 것으로, 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성을 해야한다.<br>

결론은 시스템을 구현할 때 새로운 자료 타입을 추가하는 유연성이 필요할땐 객체가 적합하고,
다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료구조와 절차적인 코드가 적합하다.
<br><br><br>


## 오류 처리
흩어진 오류 처리 코드 때문에 실제 코드가 하는 일을 파악하기가 힘들 수 있으므로 오류 처리를 잘하는 것도 깨끗한 코드를 작성할 때 중요하다.
<br>

#### 오류 코드보다 예외를 사용한다
<br>

#### Try-Catch-Finally 문을 작성한다
try 블록은 트랜잭션과 비슷하다. try 에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다. 
try-catch 범위를 정의하고 TDD 를 사용해 필요한 나머지 논리를 추가하는 식으로 작성을 하는 것이 좋다. 
강제로 예외 일으키는 테스트 케이스 작성 -> 테스트 통과하는 코드 작성 하면 try 블록의 트랜잭션 번위부터 구현하여 본질 유지하기 쉬워진다.
<br>

#### 미확인(unchecked) 예외를 사용한다.
확인된 예외는 OCP(Open Closed Principle) 을 위반한다.
하위 단계에서 코드 변경하면 상위 단계 메서드 선언부를 전부 고쳐야한다. 
예를 들어 대규모 시스템에서 호출이 일어나는 방식은 최상위 함수가 아래 함수를 호출하는 식으로 순차적으로 호출이 되는데 단걔를 내려갈수록 호출하는 함수 수가 늘어난다.
최하위 함수를 변경해 새로운 오류를 던지면 함수는 선언부에 throw 절을 추가해야하고,
변경한 함수를 호출하는 함수 모두가 catch 블록에서 새로운 예외를 처리하거나 선언부에 throw 적을 추가해야한다. (연쇄적인 수정 -> 캡슐화가 깨진다)
<br>

#### 예외에 의미를 제공한다.
오류 메세지에 정보를 담아 예외와 함께 던진다(실패한 연산이름, 실패 유형 등을 catch 에 오류 기록을 남기면 애플리케이션 로깅 기능 사용할 때 유용)
<br>

#### 호출자를 고려해 예외 클래스를 정의한다. 
오류를 분류할 때 발생한 컴포넌트로 분류, 유형으로 분류 등으로 분류하여 오류 잡아내는 방법을 생각해야한다.
<br>

#### 정상 흐름을 정의한다.
클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식(특수 사례 패턴) 을 사용한다.
<br>

#### null 을 반환하지 않는다.
미리 정의된 읽기 전용 리스트 Collections.emptyList() 를 반환하면 NullPoointerException 이 발생할 가능성도 줄어든다. (ebook,P139-140 참고)
<br>

#### null 을 전달하지 않는다.
null 일 때 throw ~Exception 을 반환하거나 assert 를 사용하여 오류메세지를 띄우는 방식 등으로 null 을 넘기지 못하도록 방지한다. 
<br><br><br>


## 경계
개발할 때 패키지 사고, 오픈 소스 이용, 타팀이 제공하는 컴포넌트 사용할 때 외부 코드를 깔끔하게 통합해야 한다.
<br>

#### 외부 코드 사용하기
Java.util.Map 에 대한 코드(ebook, P144-146) 는 기능성, 유연성은 좋지만 위험도도 크다
ex) 넘기는 쪽에서 삭제하지 않을거라 생각하고 넘겼지만 clear() 메서드 권한이 누구에게든 있고, 또 다른 누군가는 객체 유형을 임의로 추가 할 수도 있다.
클래스 안으로 경계 인터페이스인 Map 을 숨긴다. (클래스나 클래스 계열 밖으로 노출되지 않도록 주의) Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.
<br>

#### 경계 살피고 익히기
문서를 읽고, 외부 코드를 나의 코드에 작성해 라이브러리가 동작하는 지 확인한다.
또는 바로 적용하기 보다는 외부 코드에 대해 간단한 테스트 케이스를 작성해 익한다. (=학습테스트)
학습 테스트를 통해 버전이 호환되지 않는 등의 이슈를 밝혀낼 수 있다.
<br>

#### 아직 존재하지 않는 코드 사용하기 (ebook, P150-1 참고) 
<br>

#### 깨끗한 경계
소프트웨어 설계가 우수하다면 변경하는데 많은 투자와 재작업이 필요하지 않지만 통제 못하는 코드를 사용할 때는 주의가 필요하다.
경계에 위치하는 코드를 꼭 깔끔히 분리하고 테스트 케이스도 작성이 필요하다.
외부 패키지에 의존하는 대신 우리코드에 의존해야하며, 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하는 것이 필요하다.
새로운 클래스로 경계를 감싸거나 Adapter 패턴을 사용하여 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환한다. 
<br><br><br>




