
## 자바 성능 튜닝 이야기 







#### Spring Framework 사용 시 주의
-&nbsp; 성능 문제가 가장 많이 발생하는 부분은 Proxy 와 연관 되어있다. ( @Transactional 시 [나중에 더 찾아보기] ) <br>
Proxy 는 실행 시에 생성되고 개발 환경에서 작은 요청에는 이상 없다가, 요청량이 증가하는 운영 상황으로 넘어가면 문제가 발생할 수 있다. <br>
-&nbsp; 내부 매커니즘에서 사용하는 캐시 사용 시에도 주의 <br>
ex) Controller 에서 return 할 때 View 이름을 문자열로 반환 대신에 뷰 객체 자체를 반환 (메모리 릭 방지 가능) <br>
```
 return "redirect:/url/" + id;     // X
 return RedirectView("/url/"+id);   // O
```
<br>

#### 명령어
gc 상황 모니터링 - jstat <br>
ex) jstat -gcutil 5376 5s  <br>
heap dump - jvm 의 힙 메모리에서 점유하고 있는 객체에 대한 정보를 파일로 생성해놓은 것  <br>
OutOfMemoryError 발생했을 때 저장하려면 -XX:+HeapDumpOnOutMemoryError 옵션 추가  <br>
경로 지정은 -XX:HeapDumpPath=/app/tomcat/dump/  <br>
<br>

#### synchronized <br>
-&nbsp;하나의 객체를 여러 스레드에서 동시에 사용하는 경우,  static 으로 선언한 객체를 여러 스레드에서 동시에 사용하는 경우에만 사용 <br>
-&nbsp;남발할 경우 속도가 느려지기 때문에 성능 저하가 발생할 수 있다.  <br>
 <br>
 
#### synchronized,  static synchronized  <br>
synchronized -&nbsp; 현재 인스턴스에서만 동기화  <br>
static synchronized - 해당 클래스의 클래스 객체 동기화  <br>
(https://stackoverflow.com/questions/6367885/difference-between-synchronizing-a-static-method-and-a-non-static-method) <br>
<br>
<br>



####  reflectioln -&nbsp; jvm 에 로딩되어 있는 클래스와 메서드 정보를 읽어올 수 있다. <br>
```
src.getClass().getName().equals("java.math.BigDecimal")   // 시간과 메모리가 낭비됨  X 
src instanceof java.math.BigDecimal  // O
```
<br>


프로세스와 스레드 관계는 일대다 관계.<br>
스레드 구현 방법<br>
1.&nbsp;Thread 클래스 상속<br>
2.&nbsp;Runnable 인터페이스 구현 <br>
-&nbsp; 원하는 기능 추가 가능. 해당 클래스를 수행할 때 별도의 스레드 객체를 생성<br>
-&nbsp; 자바는 다중상속을 인정하지 않기 때문에 이미 상속받은 클래스가 있다면 Runnable 인터페이스를 구현.<br>
<br>



#### static 시 주의사항<br>
-&nbsp; 자주 사용하거나 절대 안변하는 변수 일 경우 final static 사용, 변하는데 static 으로 사용하는 경우에는 모든 스레드에서 동일한 주소를 가리키게 되어 문제 발생 ( 동시성 문제 해결을 위해 synchronize를 사용하여 추가 작업 필요)<br>
-&nbsp; 설정 파일 정보도 static 으로 관리<br>
-&nbsp; static 으로 선언된 부분은 gc 가 되지 않으므로 성능 향상에 도움되지만 static 필드에 너무 많은 양의 데이터가 계속해서 쌓이게 되면 OutOfMemory가 발생할 수도 있다.<br>
 -> 시스템 재시작, 해당 인스턴스 서비스 불가능 발생, 메모리 릭(memory leak : 더 이상 사용 가능한 메모리가 없어지는 현상)
<br>
<br>

#### set, list, map
일반적으로 set 은 여러 데이터를 넣어두고 해당 데이터가 존재하는지를 확인하는 용도로 많이 쓰임<br>
HashSet -&nbsp; 순서 상관없이 해쉬테이블에 저장<br>
LinkedHashSet -&nbsp; 저장된 순서에 따라서 결정<br>
TreeSet -&nbsp; red-black 이라는 tree 에 담고, 순서가 정해져있다. 담으면서 동시에 정렬하여 속도가 느리게 나오지만 사용하는 이유는 데이터를 순서에 따라 탐색하는 작업이 필요할 때는 사용하는게 좋다 <br>
속도는 일반적으로 LinkedHashSet <= HashSet < TreeSet (높음)<br>
<br>

ArrayList, Vector, LinkedList 는 넣는 속도는 큰 차이 없음.<br>
데이터를 가져올 때는 LinkedList 가 오래걸리는데 이유는 Queue 인터페이스를 상속받기 때문에 peek()을 사용해서 가져와야한다.<br>
ArrayList 는 여러 스레드에서 접근할 경우 문제 발생, Vector 는 여러 스레드에서 접근할 경우를 방지하기 위해서 get() 에 synchronized 가 선언되어 있어 성능 저하가 발생한다. <br>
삭제 할 때는 첫번째 값과 마지막 값을 삭제할 경우 ArrayList , vector 는 모든 데이터가 이동 되므로 속도 차이가 크다 <br>
<br>

map 은 추가 작업은 비슷하고 get() 메서드를 사용해서 꺼내는 경우 TreeMap 이 가장 느림<br>
일반적으로  HashSet, ArrayList, HashMap, LinkedList 를 각각 많이 사용한다. <br>
<br>
<br>



#### stringBuffer  클래스랑 StringBuilder 클래스<br>
##### 버퍼 <br>
-&nbsp; 스레드에 안전하게 설계되어 있으므로, 여러개의 스레드에서 하나의 StringBuffer 객체를 처리해도 문제가 되지 않음<br>
언제사용? <br>
스레드에 안전한 프로그램이 필요할 때나, 개발중인 시스템의 부분이 스레드에 안전한지 모르는 경우<br>
singleton 으로 선언된 클래스에 선언된 문자열인 경우 <br>
<br>

##### 빌더<br>
-&nbsp; 단일 스레드에서의 안정성만을 보장<br>
여러개의 스레드에서 하나의 StringBuilder 객체를 처리하면 문제 발생.<br>
언제사용?<br>
메서드 내에 변수 사용했을 때, 해당 변수는 그 메서드 내에서만 살아있기 때문에 StringBuilder 사용.<br>
<br>

##### String / StringBuffer / StringBuilder
```
String data = "ABC";<br>
String a = new String();<br>
StringBuffer b = new StringBuffer();<br>
StringBuilder c = new StringBuilder();<br>
<br>

a += data;
b.append(data);
c.append(data);
String tmp = c.toString();
```

각각 for 문으로 돌려서 성능 측정할 때 시간, 성능 차이가 크게 나는 이유는 a+= data; 로 하면 이전에 있던 객체는 필요없는 쓰레기 값이 되어 gc 대상에 포함되기 때문.<br>
<br>

